package com.uwb.bt2j.indexer;

import org.omg.CORBA_2_3.portable.OutputStream;

import com.uwb.bt2j.indexer.types.EList;

public class DifferenceCoverSample <TStr, T>{
	private TStr _text;
	private int _v;
	private boolean _verbose;
	private boolean _sanity;
	private EList<Integer> _ds;
	private EList<Integer> _dmap;
	private int _d;
	private EList<Long> _doffs;
	private EList<Long> _isaPrime;
	private EList<Integer> _dInv;
	private int _log2v;
	private long _vmask;
	private OutputStream _logger;
	
	public static int dc0to64[][] = {
			{0xffffffff},                     // 0
			{0xffffffff},                     // 1
			{0xffffffff},                     // 2
			{1, 0},                           // 3
			{1, 2, 0},                        // 4
			{1, 2, 0},                        // 5
			{1, 3, 0},                        // 6
			{1, 3, 0},                        // 7
			{1, 2, 4, 0},                     // 8
			{1, 2, 4, 0},                     // 9
			{1, 2, 5, 0},                     // 10
			{1, 2, 5, 0},                     // 11
			{1, 3, 7, 0},                     // 12
			{1, 3, 9, 0},                     // 13
			{1, 2, 3, 7, 0},                  // 14
			{1, 2, 3, 7, 0},                  // 15
			{1, 2, 5, 8, 0},                  // 16
			{1, 2, 4, 12, 0},                 // 17
			{1, 2, 5, 11, 0},                 // 18
			{1, 2, 6, 9, 0},                  // 19
			{1, 2, 3, 6, 10, 0},              // 20
			{1, 4, 14, 16, 0},                // 21
			{1, 2, 3, 7, 11, 0},              // 22
			{1, 2, 3, 7, 11, 0},              // 23
			{1, 2, 3, 7, 15, 0},              // 24
			{1, 2, 3, 8, 12, 0},              // 25
			{1, 2, 5, 9, 15, 0},              // 26
			{1, 2, 5, 13, 22, 0},             // 27
			{1, 4, 15, 20, 22, 0},            // 28
			{1, 2, 3, 4, 9, 14, 0},           // 29
			{1, 2, 3, 4, 9, 19, 0},           // 30
			{1, 3, 8, 12, 18, 0},             // 31
			{1, 2, 3, 7, 11, 19, 0},          // 32
			{1, 2, 3, 6, 16, 27, 0},          // 33
			{1, 2, 3, 7, 12, 20, 0},          // 34
			{1, 2, 3, 8, 12, 21, 0},          // 35
			{1, 2, 5, 12, 14, 20, 0},         // 36
			{1, 2, 4, 10, 15, 22, 0},         // 37
			{1, 2, 3, 4, 8, 14, 23, 0},       // 38
			{1, 2, 4, 13, 18, 33, 0},         // 39
			{1, 2, 3, 4, 9, 14, 24, 0},       // 40
			{1, 2, 3, 4, 9, 15, 25, 0},       // 41
			{1, 2, 3, 4, 9, 15, 25, 0},       // 42
			{1, 2, 3, 4, 10, 15, 26, 0},      // 43
			{1, 2, 3, 6, 16, 27, 38, 0},      // 44
			{1, 2, 3, 5, 12, 18, 26, 0},      // 45
			{1, 2, 3, 6, 18, 25, 38, 0},      // 46
			{1, 2, 3, 5, 16, 22, 40, 0},      // 47
			{1, 2, 5, 9, 20, 26, 36, 0},      // 48
			{1, 2, 5, 24, 33, 36, 44, 0},     // 49
			{1, 3, 8, 17, 28, 32, 38, 0},     // 50
			{1, 2, 5, 11, 18, 30, 38, 0},     // 51
			{1, 2, 3, 4, 6, 14, 21, 30, 0},   // 52
			{1, 2, 3, 4, 7, 21, 29, 44, 0},   // 53
			{1, 2, 3, 4, 9, 15, 21, 31, 0},   // 54
			{1, 2, 3, 4, 6, 19, 26, 47, 0},   // 55
			{1, 2, 3, 4, 11, 16, 33, 39, 0},  // 56
			{1, 3, 13, 32, 36, 43, 52, 0},    // 57

			// Generated by calcExhaustiveDC()
			{1, 2, 3, 7, 21, 33, 37, 50, 0},  // 58
			{1, 2, 3, 6, 13, 21, 35, 44, 0},  // 59
			{1, 2, 4, 9, 15, 25, 30, 42, 0},  // 60
			{1, 2, 3, 7, 15, 25, 36, 45, 0},  // 61
			{1, 2, 4, 10, 32, 39, 46, 51, 0}, // 62
			{1, 2, 6, 8, 20, 38, 41, 54, 0},  // 63
			{1, 2, 5, 14, 16, 34, 42, 59, 0}  // 64
	};
	
	public DifferenceCoverSample(TStr __text,
            int __v,
            boolean __verbose,
            boolean __sanity,
            OutputStream __logger) {
		_dInv.resizeExact((int)v());
		_dInv.fill(0xffffffff);
		int lim = (int)_ds.size();
		for(int i = 0; i < lim; i++) {
			_dInv.get(_ds.get(i)) = i;
		}
	}
	
	public boolean dcRepOk(TStr v, EList<TStr> ds) {
		// diffs[] records all the differences observed
		boolean[] covered(v, EBWT_CAT);
		for(T i = 1; i < v; i++) {
			covered[i] = false;
		}
		for(TStr di = TStr(); di < ds.size(); di++) {
			for(T dj = di+1; dj < ds.size(); dj++) {
				T d1 = (ds[dj] - ds[di]);
				T d2 = (ds[di] + v - ds[dj]);
				covered[d1] = true;
				covered[d2] = true;
			}
		}
		boolean ok = true;
		for(T i = 1; i < v; i++) {
			if(covered[i] == false) {
				ok = false;
				break;
			}
		}
		return ok;
	}
	
	public void doBuiltSanityCheck() {
		int v = this.v();
		VMSG_NL("  Doing sanity check");
		long added = 0;
		EList<long> sorted;
		sorted.resizeExact(_isaPrime.size());
		sorted.fill(IndexTypes.OFF_MASK);
		for(int di = 0; di < this.d(); di++) {
			int d = _ds[di];
			int i = 0;
			for(int doi = _doffs[di]; doi < _doffs[di+1]; doi++, i++) {
				// Maps the offset of the suffix to its rank
				sorted[_isaPrime[doi]] = (long)(v*i + d);
				added++;
			}
		}
	}
	
	public void buildSPrime(EList<Long> sPrime, int padding) {
		const TStr& t = this.text();
		const EList<int> ds = this.ds();
		long tlen = (long)t.length();
		int v = this.v();
		int d = this.d();
		// Record where each d section should begin in sPrime
		long tlenDivV = this.divv(tlen);
		int tlenModV = this.modv(tlen);
		long sPrimeSz = 0;
		_doffs.resizeExact((int)d+1);
		for(int di = 0; di < d; di++) {
			// mu mapping
			long sz = tlenDivV + ((ds[di] <= tlenModV) ? 1 : 0);
			_doffs[di] = sPrimeSz;
			sPrimeSz += sz;
		}
		_doffs[d] = sPrimeSz;

		// Size sPrime appropriately
		sPrime.resizeExact((int)sPrimeSz + padding);
		sPrime.fill(IndexTypes.OFF_MASK);
		// Slot suffixes from text into sPrime according to the mu
		// mapping; where the mapping would leave a blank, insert a 0
		long added = 0;
		long i = 0;
		for(long ti = 0; ti <= tlen; ti += v) {
			for(int di = 0; di < d; di++) {
				long tti = ti + ds[di];
				if(tti > tlen) break;
				long spi = _doffs[di] + i;
				sPrime[spi] = tti; added++;
			}
			i++;
		}
	}
	
	public boolean suffixSameUpTo(TStr host, long suf1, long suf2, long v) {
		for(long i = 0; i < v; i++) {
			boolean endSuf1 = suf1+i >= host.length();
			boolean endSuf2 = suf2+i >= host.length();
			if((endSuf1 && !endSuf2) || (!endSuf1 && endSuf2)) return false;
			if(endSuf1 && endSuf2) return true;
			if(host[suf1+i] != host[suf2+i]) return false;
		}
		return true;
	}
	
	public boolean isCovered(long i) {
		int modi = this.modv(i);
		return _dInv[modi] != 0xffffffff;
	}
	
	public void build(int nthreads) {
		// Local names for relevant types
		VMSG_NL("Building DifferenceCoverSample");
		// Local names for relevant data
		const TStr& t = this.text();
		int v = this.v();
		// Build s'
		EList<long> sPrime;
		// Need to allocate 2 extra elements at the end of the sPrime and _isaPrime
		// arrays.  One element that's less than all others, and another that acts
		// as needed padding for the Larsson-Sadakane sorting code.
		int padding = 1;
		VMSG_NL("  Building sPrime");
		buildSPrime(sPrime, padding);
		int sPrimeSz = sPrime.size() - padding;
		long nextRank = 0;
		{
			VMSG_NL("  Building sPrimeOrder");
			EList<long> sPrimeOrder;
			sPrimeOrder.resizeExact(sPrimeSz);
			for(long i = 0; i < sPrimeSz; i++) {
				sPrimeOrder[i] = i;
			}
			// sPrime now holds suffix-offsets for DC samples.
			{
				VMSG_NL("  V-Sorting samples");
				// Extract backing-store array from sPrime and sPrimeOrder;
				// the mkeyQSortSuf2 routine works on the array for maximum
				// efficiency
				long *sPrimeArr = (long*)sPrime.ptr();
				assert_eq(sPrimeArr[0], sPrime[0]);
				assert_eq(sPrimeArr[sPrimeSz-1], sPrime[sPrimeSz-1]);
				long *sPrimeOrderArr = (long*)sPrimeOrder.ptr();
				assert_eq(sPrimeOrderArr[0], sPrimeOrder[0]);
				assert_eq(sPrimeOrderArr[sPrimeSz-1], sPrimeOrder[sPrimeSz-1]);
				// Sort sample suffixes up to the vth character using a
				// multikey quicksort.  Sort time is proportional to the
				// number of samples times v.  It isn't quadratic.
				// sPrimeOrder is passed in as a swapping partner for
				// sPrimeArr, i.e., every time the multikey qsort swaps
				// elements in sPrime, it swaps the same elements in
				// sPrimeOrder too.  This allows us to easily reconstruct
				// what the sort did.
				if(nthreads == 1) {
					mkeyQSortSuf2(t, sPrimeArr, sPrimeSz, sPrimeOrderArr, 4,
					              this.verbose(), this.sanityCheck(), v);
				} else {
					int query_depth = 0;
					int tmp_nthreads = nthreads;
					while(tmp_nthreads > 0) {
						query_depth++;
						tmp_nthreads >>= 1;
					}
					EList<int> boundaries; // bucket boundaries for parallelization
					long *sOrig = NULL;
					if(this.sanityCheck()) {
						sOrig = new long[sPrimeSz];
						memcpy(sOrig, sPrimeArr, IndexTypes.OFF_SIZE * sPrimeSz);
					}
					mkeyQSortSuf2(t, sPrimeArr, sPrimeSz, sPrimeOrderArr, 4,
					              this.verbose(), false, query_depth, &boundaries);
					if(boundaries.size() > 0) {
	#ifdef WITH_TBB
						tbb::task_group tbb_grp;
	#else
						AutoArray<tthread::thread*> threads(nthreads);
	#endif
						EList<VSortingParam<TStr> > tparams;
						int cur = 0;
						MUTEX_T mutex;
						tparams.resize(nthreads);
						for(int tid = 0; tid < nthreads; tid++) {
							// Calculate bucket sizes by doing a binary search for each
							// suffix and noting where it lands
							tparams[tid].dcs = this;
							tparams[tid].sPrimeArr = sPrimeArr;
							tparams[tid].sPrimeSz = sPrimeSz;
							tparams[tid].sPrimeOrderArr = sPrimeOrderArr;
							tparams[tid].depth = query_depth;
							tparams[tid].boundaries = &boundaries;
							tparams[tid].cur = &cur;
							tparams[tid].mutex = &mutex;
	#ifdef WITH_TBB
							tbb_grp.run(VSorting_worker<TStr>(((void*)&tparams[tid])));
						}
						tbb_grp.wait();
	#else
							threads[tid] = new tthread::thread(VSorting_worker<TStr>, (void*)&tparams[tid]);
						}
						for (int tid = 0; tid < nthreads; tid++) {
							threads[tid].join();
						}
	#endif
					}
					if(this.sanityCheck()) {
						sanityCheckOrderedSufs(t, t.length(), sPrimeArr, sPrimeSz, v);
						for(int i = 0; i < sPrimeSz; i++) {
							assert_eq(sPrimeArr[i], sOrig[sPrimeOrderArr[i]]);
						}
						delete[] sOrig;
					}
				}
				// Make sure sPrime and sPrimeOrder are consistent with
				// their respective backing-store arrays
			}
			// Now assign the ranking implied by the sorted sPrime/sPrimeOrder
			// arrays back into sPrime.
			VMSG_NL("  Allocating rank array");
			_isaPrime.resizeExact(sPrime.size());

			{
				Timer timer(cout, "  Ranking v-sort output time: ", this.verbose());
				VMSG_NL("  Ranking v-sort output");
				for(int i = 0; i < sPrimeSz-1; i++) {
					// Place the appropriate ranking
					_isaPrime[sPrimeOrder[i]] = nextRank;
					// If sPrime[i] and sPrime[i+1] are identical up to v, then we
					// should give the next suffix the same rank
					if(!suffixSameUpTo(t, sPrime[i], sPrime[i+1], v)) nextRank++;
				}
				_isaPrime[sPrimeOrder[sPrimeSz-1]] = nextRank; // finish off
			}
			// sPrimeOrder is destroyed
			// All the information we need is now in _isaPrime
		}
		_isaPrime[_isaPrime.size()-1] = (long)sPrimeSz;
		sPrime[sPrime.size()-1] = (long)sPrimeSz;
		// _isaPrime[_isaPrime.size()-1] and sPrime[sPrime.size()-1] are just
		// spacer for the Larsson-Sadakane routine to use
		{
			VMSG_NL("  Invoking Larsson-Sadakane on ranks");
			if(sPrime.size() >= LS_SIZE) {
				cerr << "Error; sPrime array has so many elements that it can't be converted to a signed array without overflow." << endl;
				throw 1;
			}
			LarssonSadakane<TIndexOff> ls;
			ls.suffixsort(
				(TIndexOff*)_isaPrime.ptr(),
				(TIndexOff*)sPrime.ptr(),
				(TIndexOff)sPrimeSz,
				(TIndexOff)sPrime.size(),
				0);
		}
		// chop off final character of _isaPrime
		_isaPrime.resizeExact(sPrimeSz);
		for(int i = 0; i < _isaPrime.size(); i++) {
			_isaPrime[i]--;
		}
	#ifndef NDEBUG
		for(int i = 0; i < sPrimeSz-1; i++) {
			assert_lt(_isaPrime[i], sPrimeSz);
			assert(i == 0 || _isaPrime[i] != _isaPrime[i-1]);
		}
	#endif
		VMSG_NL("  Sanity-checking and returning");
		if(this.sanityCheck()) doBuiltSanityCheck();
	}
	
	public long rank(long i) {
		int imodv = this.modv(i);
		long ioff = this.divv(i);
		long isaIIdx = _doffs[_dInv[imodv]] + ioff;
		long isaPrimeI = _isaPrime[isaIIdx];
		return isaPrimeI;
	}
	
	public long breakTie(long i, long j) {
		int imodv = this.modv(i);
		int jmodv = this.modv(j);
		int dimodv = _dInv[imodv];
		int djmodv = _dInv[jmodv];
		long ioff = this.divv(i);
		long joff = this.divv(j);
		// assert_lt: expected (32024) < (0)
		long isaIIdx = _doffs[dimodv] + ioff;
		long isaJIdx = _doffs[djmodv] + joff;
		long isaPrimeI = _isaPrime[isaIIdx];
		long isaPrimeJ = _isaPrime[isaJIdx];
		return (int64_t)isaPrimeI - (int64_t)isaPrimeJ;
	}
	
	public int tieBreakOff(long i, long j) {
		const TStr& t = this.text();
		const EList<int>& dmap = this.dmap();
		// It's actually convenient to allow this, but we're permitted to
		// return nonsense in that case
		if(t[i] != t[j]) return 0xffffffff;
		//assert_eq(t[i], t[j]); // if they're unequal, there's no tie to break
		int v = this.v();
		int imod = this.modv(i);
		int jmod = this.modv(j);
		int diffLeft = (jmod >= imod)? (jmod - imod) : (jmod + v - imod);
		int diffRight = (imod >= jmod)? (imod - jmod) : (imod + v - jmod);
		int destLeft = dmap[diffLeft];   // offset where i needs to be
		int destRight = dmap[diffRight]; // offset where i needs to be
		int deltaLeft = (destLeft >= imod)? (destLeft - imod) : (destLeft + v - imod);
		if(deltaLeft == v) deltaLeft = 0;
		int deltaRight = (destRight >= jmod)? (destRight - jmod) : (destRight + v - jmod);
		if(deltaRight == v) deltaRight = 0;
		return min(deltaLeft, deltaRight);
	}
	
	public boolean increasing(T ts, int limit) {
		for(int i = 0; i < limit-1; i++) {
			if(ts[i+1] <= ts[i]) return false;
		}
		return true;
	}
	
	public boolean hasDifference(T ds, T d, T v, T diff) {
		// diffs[] records all the differences observed
		for(T di = T(); di < d; di++) {
			for(T dj = di+1; dj < d; dj++) {
				T d1 = (ds[dj] - ds[di]);
				T d2 = (ds[di] + v - ds[dj]);
				if(d1 == diff || d2 == diff) return true;
			}
		}
		return false;
	}
	
	public void calcExhaustiveDC(T i, boolean verbose, boolean sanityCheck) {
		T v = i;
		boolean[] diffs(v, EBWT_CAT);
		// v is the target period
		T ld = (T)ceil(sqrt(v));
		// ud is the upper bound on |D|
		T ud = v / 2;
		// for all possible |D|s
		boolean ok = true;
		T *ds = null;
		T d;
		for(d = ld; d <= ud+1; d++) {
			// for all possible |D| samples
			AutoArray<T> ds(d, EBWT_CAT);
			for(T j = 0; j < d; j++) {
				ds[j] = j;
			}
			assert(increasing(ds, d));
			while(true) {
				// reset diffs[]
				for(T t = 1; t < v; t++) {
					diffs[t] = false;
				}
				T diffCnt = 0;
				// diffs[] records all the differences observed
				for(T di = 0; di < d; di++) {
					for(T dj = di+1; dj < d; dj++) {
						T d1 = (ds[dj] - ds[di]);
						T d2 = (ds[di] + v - ds[dj]);
						if(!diffs[d1]) diffCnt++; diffs[d1] = true;
						if(!diffs[d2]) diffCnt++; diffs[d2] = true;
					}
				}
				// Do we observe all possible differences (except 0)
				ok = diffCnt == v-1;
				if(ok) {
					// Yes, all differences are covered
					break;
				} else {
					// Advance ds
					// (Following is commented out because it turns out
					// it's slow)
					// Find a missing difference
					//int missing = 0xffffffff;
					//for(int t = 1; t < v; t++) {
					//	if(diffs[t] == false) {
					//		missing = diffs[t];
					//		break;
					//	}
					//}
					//assert_neq(missing, 0xffffffff);
					boolean advanced = false;
					boolean keepGoing = false;
					do {
						keepGoing = false;
						for(T bd = d-1; bd > 1; bd--) {
							T dif = (d-1)-bd;
							if(ds[bd] < v-1-dif) {
								ds[bd]++;
								// Reset subsequent ones
								for(T bdi = bd+1; bdi < d; bdi++) {
									ds[bdi] = ds[bdi-1]+1;
								}
								// (Following is commented out because
								// it turns out it's slow)
								// See if the new DC has the missing value
								//if(!hasDifference(ds, d, v, missing)) {
								//	keepGoing = true;
								//	break;
								//}
								advanced = true;
								break;
							} else {
								ds[bd] = 0;
								// keep going
							}
						}
					} while(keepGoing);
					// No solution for this |D|
					if(!advanced) break;
				}
			} // next sample assignment
			if(ok) {
				break;
			}
		} // next |D|
		System.out.println("Did exhaustive v=" + v + " |D|=" + d );
		System.out.print("  ");
		for(T i = 0; i < d; i++) {
			System.out.print( ds[i]);
			if(i < d-1) System.out.print(",");
		}
		System.out.println();
	}
	
	public void calcColbournAndLingDCs(boolean verbose, boolean sanityCheck) {
		for(T r = 0; r < 16; r++) {
			T maxv = 24*r*r + 36*r + 13; // Corollary 2.3
			T numsamp = 6*r + 4;
			clDCs[r].maxV = maxv;
			clDCs[r].numSamples = numsamp;
			T i;
			// clDCs[r].samples[0] = 0;
			// Fill in the 1^r part of the B series
			for(i = 1; i < r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 1;
			}
			// Fill in the (r + 1)^1 part
			clDCs[r].samples[r+1] = clDCs[r].samples[r] + r + 1;
			// Fill in the (2r + 1)^r part
			for(i = r+2; i < r+2+r; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 2*r + 1;
			}
			// Fill in the (4r + 3)^(2r + 1) part
			for(i = r+2+r; i < r+2+r+2*r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 4*r + 3;
			}
			// Fill in the (2r + 2)^(r + 1) part
			for(i = r+2+r+2*r+1; i < r+2+r+2*r+1+r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 2*r + 2;
			}
			// Fill in the last 1^r part
			for(i = r+2+r+2*r+1+r+1; i < r+2+r+2*r+1+r+1+r; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 1;
			}
			if(sanityCheck) {
				// diffs[] records all the differences observed
				boolean[] diffs(maxv, EBWT_CAT);
				for(T i = 0; i < numsamp; i++) {
					for(T j = i+1; j < numsamp; j++) {
						T d1 = (clDCs[r].samples[j] - clDCs[r].samples[i]);
						T d2 = (clDCs[r].samples[i] + maxv - clDCs[r].samples[j]);
						diffs[d1] = true;
						diffs[d2] = true;
					}
				}
				// Should have observed all possible differences (except 0)
				for(T i = 1; i < maxv; i++) {
					if(diffs[i] == false) System.out.println(r + ", " + i);
				}
			}
		}
		clDCs_calced = true;
	}
	
	public EList<T> getDiffCover(T v, boolean verbose, boolean sanityCheck) {
		EList<T> ret;
		ret.clear();
		// Can we look it up in our hardcoded array?
		if(v <= 64 && dc0to64[v][0] == 0xffffffff) {
			if(verbose) System.out.println( "v in hardcoded area, but hardcoded entry was all-fs");
			return ret;
		} else if(v <= 64) {
			ret.push_back(0);
			for(int i = 0; i < 10; i++) {
				if(dc0to64[v][i] == 0) break;
				ret.push_back(dc0to64[v][i]);
			}
			return ret;
		}

		// Can we look it up in our calcColbournAndLingDCs array?
		if(!clDCs_calced) {
			calcColbournAndLingDCs(verbose, sanityCheck);
		}
		for(int i = 0; i < 16; i++) {
			if(v <= clDCs[i].maxV) {
				for(int j = 0; j < clDCs[i].numSamples; j++) {
					T s = clDCs[i].samples[j];
					if(s >= v) {
						s %= v;
						for(int k = 0; k < ret.size(); k++) {
							if(s == ret[k]) break;
							if(s < ret[k]) {
								ret.insert(s, k);
								break;
							}
						}
					} else {
						ret.push_back(s % v);
					}
				}
				return ret;
			}
		}
		System.err.println("Error: Could not find a difference cover sample for v=" + v);
	}
	
	public EList<T> getDeltaMap(T v, EList<T> dc) {
		// Declare anchor-map-related items
		EList<T> amap;
		int amapEnts = 1;
		amap.resizeExact((int)v);
		amap.fill(0xffffffff);
		amap[0] = 0;
		// Print out difference cover (and optionally calculate
		// anchor map)
		for(int i = 0; i < dc.size(); i++) {
			for(int j = i+1; j < dc.size(); j++) {
				T diffLeft  = dc[j] - dc[i];
				T diffRight = dc[i] + v - dc[j];
				if(amap[diffLeft] == 0xffffffff) {
					amap[diffLeft] = dc[i];
					amapEnts++;
				}
				if(amap[diffRight] == 0xffffffff) {
					amap[diffRight] = dc[j];
					amapEnts++;
				}
			}
		}
		return amap;
	}
	
	public int popCount(T i) {
		int cnt = 0;
		for(int j = 0; j < sizeof(T)*8; j++) {
			if(i & 1) cnt++;
			i >>= 1;
		}
		return cnt;
	}
	
	public int myLog2(T i) {
		for(int j = 0; j < sizeof(T)*8; j++) {
			if(i & 1) return (int)j;
			i >>= 1;
		}
		return 0xffffffff;
	}
	
	public int simulateAllocs(TStr text, int v) {
		EList<int> ds(getDiffCover(v, false /*verbose*/, false /*sanity*/));
		int len = text.length();
		int sPrimeSz = (len / v) * ds.size();
		// sPrime, sPrimeOrder, _isaPrime all exist in memory at
		// once and that's the peak
		long[] aa(sPrimeSz * 3 + (1024 * 1024 /*out of caution*/), EBWT_CAT);
		return sPrimeSz * 4; // sPrime array
	}
	
	public int v() const                   { return _v; }
	public int log2v() const               { return _log2v; }
	public int vmask() const               { return _vmask; }
	public int modv(long i) const    { return (int)(i & ~_vmask); }
	public long divv(long i) const  { return i >> _log2v; }
	public int d() const                   { return _d; }
	public boolean verbose() const                 { return _verbose; }
	public boolean sanityCheck() const             { return _sanity; }
	public const TStr& text() const             { return _text; }
	public const EList<int>& ds() const    { return _ds; }
	public const EList<int>& dmap() const  { return _dmap; }
	public ostream& log() const                 { return _logger; }
	
	public void print(OutputStream out) {
		for(int i = 0; i < _text.length(); i++) {
			if(isCovered(i)) {
				out.write(rank(i));
			} else {
				out.write("-");
			}
			if(i < _text.length()-1) {
				out.write(",");
			}
		}
		out.write("\n");
	}
	
	private boolean built() {
		return _isaPrime.size() > 0;
	}
	
	private void verbose(String s) {
		if(this.verbose()) {
			this.log().write(s);
			this.log().flush();
		}
	}
}
