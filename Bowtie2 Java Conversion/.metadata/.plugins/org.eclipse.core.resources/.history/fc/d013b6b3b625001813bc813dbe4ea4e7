package com.uwb.bt2j.indexer;

import org.omg.CORBA_2_3.portable.OutputStream;

import com.uwb.bt2j.indexer.types.EList;
import com.uwb.bt2j.indexer.util.IndexTypes;

//import java.io.*;

public class DifferenceCoverSample <TStr, T>{
	private String _text;
	private int _v;
	private boolean _verbose;
	private boolean _sanity;
	private EList<Integer> _ds;
	private EList<Integer> _dmap;
	private int _d;
	private EList<Long> _doffs;
	private EList<Long> _isaPrime;
	private EList<Integer> _dInv;
	private int _log2v;
	private long _vmask;
	private OutputStream _logger;
	
	private final int EBWT_CAT = 1;
	
	public static int dc0to64[][] = {
			{0xffffffff},                     // 0
			{0xffffffff},                     // 1
			{0xffffffff},                     // 2
			{1, 0},                           // 3
			{1, 2, 0},                        // 4
			{1, 2, 0},                        // 5
			{1, 3, 0},                        // 6
			{1, 3, 0},                        // 7
			{1, 2, 4, 0},                     // 8
			{1, 2, 4, 0},                     // 9
			{1, 2, 5, 0},                     // 10
			{1, 2, 5, 0},                     // 11
			{1, 3, 7, 0},                     // 12
			{1, 3, 9, 0},                     // 13
			{1, 2, 3, 7, 0},                  // 14
			{1, 2, 3, 7, 0},                  // 15
			{1, 2, 5, 8, 0},                  // 16
			{1, 2, 4, 12, 0},                 // 17
			{1, 2, 5, 11, 0},                 // 18
			{1, 2, 6, 9, 0},                  // 19
			{1, 2, 3, 6, 10, 0},              // 20
			{1, 4, 14, 16, 0},                // 21
			{1, 2, 3, 7, 11, 0},              // 22
			{1, 2, 3, 7, 11, 0},              // 23
			{1, 2, 3, 7, 15, 0},              // 24
			{1, 2, 3, 8, 12, 0},              // 25
			{1, 2, 5, 9, 15, 0},              // 26
			{1, 2, 5, 13, 22, 0},             // 27
			{1, 4, 15, 20, 22, 0},            // 28
			{1, 2, 3, 4, 9, 14, 0},           // 29
			{1, 2, 3, 4, 9, 19, 0},           // 30
			{1, 3, 8, 12, 18, 0},             // 31
			{1, 2, 3, 7, 11, 19, 0},          // 32
			{1, 2, 3, 6, 16, 27, 0},          // 33
			{1, 2, 3, 7, 12, 20, 0},          // 34
			{1, 2, 3, 8, 12, 21, 0},          // 35
			{1, 2, 5, 12, 14, 20, 0},         // 36
			{1, 2, 4, 10, 15, 22, 0},         // 37
			{1, 2, 3, 4, 8, 14, 23, 0},       // 38
			{1, 2, 4, 13, 18, 33, 0},         // 39
			{1, 2, 3, 4, 9, 14, 24, 0},       // 40
			{1, 2, 3, 4, 9, 15, 25, 0},       // 41
			{1, 2, 3, 4, 9, 15, 25, 0},       // 42
			{1, 2, 3, 4, 10, 15, 26, 0},      // 43
			{1, 2, 3, 6, 16, 27, 38, 0},      // 44
			{1, 2, 3, 5, 12, 18, 26, 0},      // 45
			{1, 2, 3, 6, 18, 25, 38, 0},      // 46
			{1, 2, 3, 5, 16, 22, 40, 0},      // 47
			{1, 2, 5, 9, 20, 26, 36, 0},      // 48
			{1, 2, 5, 24, 33, 36, 44, 0},     // 49
			{1, 3, 8, 17, 28, 32, 38, 0},     // 50
			{1, 2, 5, 11, 18, 30, 38, 0},     // 51
			{1, 2, 3, 4, 6, 14, 21, 30, 0},   // 52
			{1, 2, 3, 4, 7, 21, 29, 44, 0},   // 53
			{1, 2, 3, 4, 9, 15, 21, 31, 0},   // 54
			{1, 2, 3, 4, 6, 19, 26, 47, 0},   // 55
			{1, 2, 3, 4, 11, 16, 33, 39, 0},  // 56
			{1, 3, 13, 32, 36, 43, 52, 0},    // 57

			// Generated by calcExhaustiveDC()
			{1, 2, 3, 7, 21, 33, 37, 50, 0},  // 58
			{1, 2, 3, 6, 13, 21, 35, 44, 0},  // 59
			{1, 2, 4, 9, 15, 25, 30, 42, 0},  // 60
			{1, 2, 3, 7, 15, 25, 36, 45, 0},  // 61
			{1, 2, 4, 10, 32, 39, 46, 51, 0}, // 62
			{1, 2, 6, 8, 20, 38, 41, 54, 0},  // 63
			{1, 2, 5, 14, 16, 34, 42, 59, 0}  // 64
	};
	
	public DifferenceCoverSample(String __text,
            int __v,
            boolean __verbose,
            boolean __sanity,
            OutputStream __logger) {
		_dInv.resizeExact((int)v());
		_dInv.fill(0xffffffff);
		int lim = (int)_ds.size();
		for(int i = 0; i < lim; i++) {
			_dInv.set(i, _ds.get(i));
		}
	}
	
	public boolean dcRepOk(String v, EList<String> ds) {
		// diffs[] records all the differences observed
		boolean[] covered = new boolean[v.length()];
		for(int i = 1; i < v.length(); i++) {
			covered[i] = false;
		}
		for(int di = 0; di < ds.size(); di++) {
			for(int dj = di+1; dj < ds.size(); dj++) {
				String d1 = ds.get(dj).substring(0, ds.get(di).length()); // (ds.get(dj) - ds.get(di));
				String d2 = ds.get(di).substring(v.length(), ds.get(di).length()); // (ds.get(di) + v - ds.get(dj));
				covered[d1.length()] = true;
				covered[d2.length()] = true;
			}
		}
		boolean ok = true;
		for(int i = 1; i < v.length(); i++) {
			if(covered[i] == false) {
				ok = false;
				break;
			}
		}
		return ok;
	}
	
	public void doBuiltSanityCheck() {
		int v = this.v();
		//VMSG_NL("  Doing sanity check");
		long added = 0;
		EList<Long> sorted = new EList<Long>();
		sorted.resizeExact(_isaPrime.size());
		sorted.fill(IndexTypes.OFF_MASK);
		for(int di = 0; di < this.d(); di++) {
			int d = _ds.get(di);
			int i = 0;
			for(long doi = _doffs.get(di); doi < _doffs.get(di+1); doi++, i++) {
				// Maps the offset of the suffix to its rank
				sorted.set((long)(v*i + d), _isaPrime.get((int)doi).intValue());
				added++;
			}
		}
	}
	
	public void buildSPrime(EList<Long> sPrime, int padding) {
		 String t = this.text();
		 EList<Integer> ds = this.ds();
		long tlen = (long)(t.length());
		int v = this.v();
		int d = this.d();
		// Record where each d section should begin in sPrime
		long tlenDivV = this.divv(tlen);
		int tlenModV = this.modv(tlen);
		long sPrimeSz = 0;
		_doffs.resizeExact((int)d+1);
		for(int di = 0; di < d; di++) {
			// mu mapping
			long sz = tlenDivV + ((ds.get(di) <= tlenModV) ? 1 : 0);
			_doffs.set(sPrimeSz, di);
			sPrimeSz += sz;
		}
		_doffs.set(sPrimeSz, d);

		// Size sPrime appropriately
		sPrime.resizeExact((int)sPrimeSz + padding);
		sPrime.fill(IndexTypes.OFF_MASK);
		// Slot suffixes from text into sPrime according to the mu
		// mapping; where the mapping would leave a blank, insert a 0
		long added = 0;
		long i = 0;
		for(long ti = 0; ti <= tlen; ti += v) {
			for(int di = 0; di < d; di++) {
				long tti = ti + ds.get(di);
				if(tti > tlen) break;
				long spi = _doffs.get(di) + i;
				sPrime.set(tti, (int)spi); added++;
			}
			i++;
		}
	}
	
	public boolean suffixSameUpTo(String host[], long suf1, long suf2, long v) {
		for(int i = 0; i < v; i++) {
			boolean endSuf1 = suf1+i >= host.length;
			boolean endSuf2 = suf2+i >= host.length;
			if((endSuf1 && !endSuf2) || (!endSuf1 && endSuf2)) return false;
			if(endSuf1 && endSuf2) return true;
			if(host[(int)suf1+i] != host[(int)suf2+i]) return false;
		}
		return true;
	}
	
	public boolean isCovered(long i) {
		int modi = this.modv(i);
		return _dInv.get(modi) != 0xffffffff;
	}

	public void build(int nthreads) {
		// Local names for relevant types
		//VMSG_NL("Building DifferenceCoverSample");
		// Local names for relevant data
		 String t = this.text();
		int v = this.v();
		// Build s'
		EList<Long> sPrime;
		// Need to allocate 2 extra elements at the end of the sPrime and _isaPrime
		// arrays.  One element that's less than all others, and another that acts
		// as needed padding for the Larsson-Sadakane sorting code.
		int padding = 1;
		//VMSG_NL("  Building sPrime");
		buildSPrime(sPrime, padding);
		int sPrimeSz = sPrime.size() - padding;
		long nextRank = 0;
			//VMSG_NL("  Building sPrimeOrder");
			EList<Long> sPrimeOrder;
			sPrimeOrder.resizeExact(sPrimeSz);
			for(long i = 0; i < sPrimeSz; i++) {
				sPrimeOrder.set(i, (int)i);
			}
			// sPrime now holds suffix-offsets for DC samples.
			{
				//VMSG_NL("  V-Sorting samples");
				// Extract backing-store array from sPrime and sPrimeOrder;
				// the mkeyQSortSuf2 routine works on the array for maximum
				// efficiency
				EList<Long> sPrimeArr = sPrime;
				//assert_eq(sPrimeArr[0], sPrime[0]);
				//assert_eq(sPrimeArr[sPrimeSz-1], sPrime[sPrimeSz-1]);
				EList<Long> sPrimeOrderArr = sPrimeOrder;
				//assert_eq(sPrimeOrderArr[0], sPrimeOrder[0]);
				//assert_eq(sPrimeOrderArr[sPrimeSz-1], sPrimeOrder[sPrimeSz-1]);
				// Sort sample suffixes up to the vth character using a
				// multikey quicksort.  Sort time is proportional to the
				// number of samples times v.  It isn't quadratic.
				// sPrimeOrder is passed in as a swapping partner for
				// sPrimeArr, i.e., every time the multikey qsort swaps
				// elements in sPrime, it swaps the same elements in
				// sPrimeOrder too.  This allows us to easily reruct
				// what the sort did.
				if(nthreads == 1) {
					mkeyQSortSuf2(t, sPrimeArr, sPrimeSz, sPrimeOrderArr, 4,
					              this.verbose(), this.sanityCheck(), v);
				} 
				/*else {
					int query_depth = 0;
					int tmp_nthreads = nthreads;
					while(tmp_nthreads > 0) {
						query_depth++;
						tmp_nthreads >>= 1;
					}
					EList<Integer> boundaries; // bucket boundaries for parallelization
					Long[] sOrig = null;
					if(this.sanityCheck()) {
						sOrig = new Long[sPrimeSz];
						memcpy(sOrig, sPrimeArr, IndexTypes.OFF_SIZE * sPrimeSz);
					}
					mkeyQSortSuf2(t, sPrimeArr, sPrimeSz, sPrimeOrderArr, 4,
					              this.verbose(), false, query_depth, boundaries);
					if(boundaries.size() > 0) {
	//#ifdef WITH_TBB
						tbb::task_group tbb_grp;
	//#else
						AutoArray<tthread::thread> threads(nthreads);
	//#endif
						EList<VSortingParam<String> > tparams;
						int cur = 0;
						MUTEX_T mutex;
						tparams.resize(nthreads);
						for(int tid = 0; tid < nthreads; tid++) {
							// Calculate bucket sizes by doing a binary search for each
							// suffix and noting where it lands
							tparams[tid].dcs = this;
							tparams[tid].sPrimeArr = sPrimeArr;
							tparams[tid].sPrimeSz = sPrimeSz;
							tparams[tid].sPrimeOrderArr = sPrimeOrderArr;
							tparams[tid].depth = query_depth;
							tparams[tid].boundaries = boundaries;
							tparams[tid].cur = cur;
							tparams[tid].mutex = mutex;
	//#ifdef WITH_TBB
							tbb_grp.run(VSorting_worker<String>(((void)tparams[tid])));
						}
						tbb_grp.wait();
	//#else
							threads[tid] = new tthread::thread(VSorting_worker<String>, (void)tparams[tid]);
						}
						for (int tid = 0; tid < nthreads; tid++) {
							threads[tid].join();
						}
	//#endif
					}*/
					if(this.sanityCheck()) {
						sanityCheckOrderedSufs(t, t.length(), sPrimeArr, sPrimeSz, v);
						for(int i = 0; i < sPrimeSz; i++) {
							//assert_eq(sPrimeArr[i], sOrig[sPrimeOrderArr[i]]);
						}
						delete[] sOrig;
					}
				}
				// Make sure sPrime and sPrimeOrder are consistent with
				// their respective backing-store arrays
			// Now assign the ranking implied by the sorted sPrime/sPrimeOrder
			// arrays back into sPrime.
			//VMSG_NL("  Allocating rank array");
			_isaPrime.resizeExact(sPrime.size());

			{
				//Timer timer(cout, "  Ranking v-sort output time: ", this.verbose());
				//VMSG_NL("  Ranking v-sort output");
				for(int i = 0; i < sPrimeSz-1; i++) {
					// Place the appropriate ranking
					_isaPrime.set(nextRank, sPrimeOrder.get(i).intValue());
					// If sPrime[i] and sPrime[i+1] are identical up to v, then we
					// should give the next suffix the same rank
					// TODO: split t into string array of characters
					char[] charArray = t.toCharArray();
					String[] stringArray = new String[charArray.length];
					for (int a = 0; a < charArray.length; a++)
						stringArray[a] = "" + charArray[a];
					if(!suffixSameUpTo(stringArray, (long)sPrime.get(i), (long)sPrime.get(i+1), (long)v)) nextRank++;
				}
				_isaPrime.set(nextRank, sPrimeOrder.get(sPrimeSz-1).intValue()); // finish off
			}
			// sPrimeOrder is destroyed
			// All the information we need is now in _isaPrime
		//}
		_isaPrime.set((long)sPrimeSz, _isaPrime.size()-1);
		sPrime.set((long)sPrimeSz, sPrime.size()-1);
		// _isaPrime[_isaPrime.size()-1] and sPrime[sPrime.size()-1] are just
		// spacer for the Larsson-Sadakane routine to use
		{
			//VMSG_NL("  Invoking Larsson-Sadakane on ranks");
			if(sPrime.size() >= LS_SIZE) {
				System.err.println("Error; sPrime array has so many elements that it can't be converted to a signed array without overflow.");
				throw new Exception();
			}
			LarssonSadakane ls;
			ls.suffixsort(
				_isaPrime,
				sPrime,
				(long)sPrimeSz,
				(long)sPrime.size(),
				0);
		}
		// chop off final character of _isaPrime
		_isaPrime.resizeExact(sPrimeSz);
		for(int i1 = 0; i1 < _isaPrime.size(); i1++) {
			_isaPrime.set(_isaPrime.get(i1) - 1, i1);
		}
	//#ifndef NDEBUG
		for(int i2 = 0; i2 < sPrimeSz-1; i2++) {
			//assert_lt(_isaPrime[i2], sPrimeSz);
			assert(i2 == 0 || _isaPrime.get(i2) != _isaPrime.get(i2-1));
		}
	//#endif
		//VMSG_NL("  Sanity-checking and returning");
		if(this.sanityCheck()) 
			doBuiltSanityCheck();
	}
	
	public long rank(long i) {
		int imodv = this.modv(i);
		long ioff = this.divv(i);
		long isaIIdx = _doffs.get(_dInv.get(imodv)) + ioff;
		long isaPrimeI = _isaPrime.get((int)isaIIdx);
		return isaPrimeI;
	}
	
	public long breakTie(long i, long j) {
		int imodv = this.modv(i);
		int jmodv = this.modv(j);
		int dimodv = _dInv.get(imodv);
		int djmodv = _dInv.get(jmodv);
		long ioff = this.divv(i);
		long joff = this.divv(j);
		// //assert_lt: expected (32024) < (0)
		long isaIIdx = _doffs.get(dimodv) + ioff;
		long isaJIdx = _doffs.get(djmodv) + joff;
		long isaPrimeI = _isaPrime.get((int)isaIIdx);
		long isaPrimeJ = _isaPrime.get((int)isaJIdx);
		return (long)isaPrimeI - (long)isaPrimeJ;
	}
	
	public int tieBreakOff(long i, long j) {
		 String t = this.text();
		 EList<Integer> dmap = this.dmap();
		// It's actually convenient to allow this, but we're permitted to
		// return nonsense in that case
		if(t.charAt((int)i) != t.charAt((int)j)) return 0xffffffff;
		////assert_eq(t[i], t[j]); // if they're unequal, there's no tie to break
		int v = this.v();
		int imod = this.modv(i);
		int jmod = this.modv(j);
		int diffLeft = (jmod >= imod)? (jmod - imod) : (jmod + v - imod);
		int diffRight = (imod >= jmod)? (imod - jmod) : (imod + v - jmod);
		int destLeft = dmap.get(diffLeft);   // offset where i needs to be
		int destRight = dmap.get(diffRight); // offset where i needs to be
		int deltaLeft = (destLeft >= imod)? (destLeft - imod) : (destLeft + v - imod);
		if(deltaLeft == v) deltaLeft = 0;
		int deltaRight = (destRight >= jmod)? (destRight - jmod) : (destRight + v - jmod);
		if(deltaRight == v) deltaRight = 0;
		return Math.min(deltaLeft, deltaRight);
	}
	
	public boolean increasing(String ts, int limit) {
		for(int i = 0; i < limit-1; i++) {
			if(ts.charAt(i+1) <= ts.charAt(i)) return false;
		}
		return true;
	}
	
	public boolean hasDifference(int[] ds, int d, int v, int diff) {
		// diffs[] records all the differences observed
		for(Integer di = null; (int)di < (int)d; di++) {
			for(int dj = di+1; dj < d; dj++) {
				int d1 = (ds[dj] - ds[di]);
				int d2 = (ds[di] + v - ds[dj]);
				if(d1 == diff || d2 == diff) return true;
			}
		}
		return false;
	}
	
	public void calcExhaustiveDC(int i, boolean verbose, boolean sanityCheck) {
		double v = i;
		boolean[] diffs = new boolean[(int)v];
		// v is the target period
		double ld = (double)Math.ceil(Math.sqrt(v));
		// ud is the upper bound on |D|
		double ud = v / 2;
		// for all possible |D|s
		boolean ok = true;
		Integer ds[] = null;
		double d;
		for(d = ld; d <= ud+1; d++) {
			// for all possible |D| samples
			//AutoArray<T> ds(d, EBWT_CAT);
			ds = new Integer[(int)d];
			for(int j = 0; j < d; j++) {
				ds[j] = j;
			}
			while(true) {
				// reset diffs[]
				for(int t = 1; t < v; t++) {
					diffs[t] = false;
				}
				int diffCnt = 0;
				// diffs[] records all the differences observed
				for(int di = 0; di < d; di++) {
					for(int dj = di+1; dj < d; dj++) {
						int d1 = (ds[dj] - ds[di]);
						int d2 = (ds[di] + (int)v - ds[dj]);
						if(!diffs[d1]) diffCnt++; diffs[d1] = true;
						if(!diffs[d2]) diffCnt++; diffs[d2] = true;
					}
				}
				// Do we observe all possible differences (except 0)
				ok = diffCnt == v-1;
				if(ok) {
					// Yes, all differences are covered
					break;
				} else {
					// Advance ds
					// (Following is commented out because it turns out
					// it's slow)
					// Find a missing difference
					//int missing = 0xffffffff;
					//for(int t = 1; t < v; t++) {
					//	if(diffs[t] == false) {
					//		missing = diffs[t];
					//		break;
					//	}
					//}
					////assert_neq(missing, 0xffffffff);
					boolean advanced = false;
					boolean keepGoing = false;
					do {
						keepGoing = false;
						for(double bd = d-1; bd > 1; bd--) {
							double dif = (d-1)-bd;
							if(ds[(int)bd] < v-1-dif) {
								ds[(int)bd]++;
								// Reset subsequent ones
								for(int bdi = (int)(bd + 1); bdi < d; bdi++) {
									ds[bdi] = ds[bdi-1]+1;
								}
								// (Following is commented out because
								// it turns out it's slow)
								// See if the new DC has the missing value
								//if(!hasDifference(ds, d, v, missing)) {
								//	keepGoing = true;
								//	break;
								//}
								advanced = true;
								break;
							} else {
								ds[(int)bd] = 0;
								// keep going
							}
						}
					} while(keepGoing);
					// No solution for this |D|
					if(!advanced) break;
				}
			} // next sample assignment
			if(ok) {
				break;
			}
		} // next |D|
		System.out.println("Did exhaustive v=" + v + " |D|=" + d );
		System.out.print("  ");
		for(int a = 0; a < d; a++) {
			System.out.print( ds[i]);
			if(a < d-1) System.out.print(",");
		}
		System.out.println();
	}
	
	//sampleEntry[] clDCs = new sampleEntry[16];
	
	public void calcColbournAndLingDCs(boolean verbose, boolean sanityCheck) {
		/* for(int r = 0; r < 16; r++) {
			int maxv = 24*r*r + 36*r + 13; // Corollary 2.3
			int numsamp = 6*r + 4;
			clDCs[r].maxV = maxv;
			clDCs[r].numSamples = numsamp;
			int i;
			// clDCs[r].samples[0] = 0;
			// Fill in the 1^r part of the B series
			for(i = 1; i < r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 1;
			}
			// Fill in the (r + 1)^1 part
			clDCs[r].samples[r+1] = clDCs[r].samples[r] + r + 1;
			// Fill in the (2r + 1)^r part
			for(i = r+2; i < r+2+r; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 2*r + 1;
			}
			// Fill in the (4r + 3)^(2r + 1) part
			for(i = r+2+r; i < r+2+r+2*r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 4*r + 3;
			}
			// Fill in the (2r + 2)^(r + 1) part
			for(i = r+2+r+2*r+1; i < r+2+r+2*r+1+r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 2*r + 2;
			}
			// Fill in the last 1^r part
			for(i = r+2+r+2*r+1+r+1; i < r+2+r+2*r+1+r+1+r; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 1;
			}
			if(sanityCheck) {
				// diffs[] records all the differences observed
				boolean[] diffs(maxv, EBWT_CAT);
				for(int a = 0; a < numsamp; a++) {
					for(int j = a+1; j < numsamp; j++) {
						int d1 = (clDCs[r].samples[j] - clDCs[r].samples[a]);
						int d2 = (clDCs[r].samples[a] + maxv - clDCs[r].samples[j]);
						diffs[d1] = true;
						diffs[d2] = true;
					}
				}
				// Should have observed all possible differences (except 0)
				for(int a = 1; a < maxv; a++) {
					if(diffs[a] == false) System.out.println(r + ", " + i);
				}
			}
		}
		clDCs_calced = true; */
	}
	
	public EList<Integer> getDiffCover(int v, boolean verbose, boolean sanityCheck) {
		EList<Integer> ret = new EList<Integer>();
		ret.clear();
		// Can we look it up in our hardcoded array?
		if(v <= 64 && dc0to64[v][0] == 0xffffffff) {
			if(verbose) System.out.println( "v in hardcoded area, but hardcoded entry was all-fs");
			return ret;
		} else if(v <= 64) {
			ret.push_back(0);
			for(int i = 0; i < 10; i++) {
				if(dc0to64[v][i] == 0) break;
				ret.push_back(dc0to64[v][i]);
			}
			return ret;
		}

		// Can we look it up in our calcColbournAndLingDCs array?
		/* if(!clDCs_calced) {
			calcColbournAndLingDCs(verbose, sanityCheck);
		}
		for(int i = 0; i < 16; i++) {
			if(v <= clDCs[i].maxV) {
				for(int j = 0; j < clDCs[i].numSamples; j++) {
					int s = clDCs[i].samples[j];
					if(s >= v) {
						s %= v;
						for(int k = 0; k < ret.size(); k++) {
							if(s == ret.get(k)) break;
							if(s < ret.get(k)) {
								ret.insert(s, k);
								break;
							}
						}
					} else {
						ret.push_back(s % v);
					}
				}
				return ret;
			}
		} */
		System.err.println("Error: Could not find a difference cover sample for v=" + v);
		return ret;
	}
	
	public EList<Integer> getDeltaMap(int v, EList<Integer> dc) {
		// Declare anchor-map-related items
		EList<Integer> amap = new EList<Integer>();
		int amapEnts = 1;
		amap.resizeExact((int)v);
		amap.fill(0xffffffff, 0, v);
		amap.set(0, 0);
		// Print out difference cover (and optionally calculate
		// anchor map)
		for(int i = 0; i < dc.size(); i++) {
			for(int j = i+1; j < dc.size(); j++) {
				int diffLeft  = dc.get(j) - dc.get(i);
				int diffRight = dc.get(i) + v - dc.get(j);
				if(amap.get(diffLeft) == 0xffffffff) {
					amap.set(dc.get(i), diffLeft);
					amapEnts++;
				}
				if(amap.get(diffRight) == 0xffffffff) {
					amap.set(dc.get(j), diffRight);
					amapEnts++;
				}
			}
		}
		return amap;
	}
	
	public int popCount(int i) {
		int cnt = 0;
		for(int j = 0; j < 32*8; j++) {
			if((i & 1) == 1) cnt++;
			i >>= 1;
		}
		return cnt;
	}
	
	public int myLog2(int i) {
		for(int j = 0; j < 32*8; j++) {
			if((i & 1) == 1) return (int)j;
			i >>= 1;
		}
		return 0xffffffff;
	}
	
	public int simulateAllocs(String text, int v) {
		EList<Integer> ds = new EList<Integer>(getDiffCover(v, false /*verbose*/, false /*sanity*/));
		int len = text.length();
		int sPrimeSz = (len / v) * ds.size();
		// sPrime, sPrimeOrder, _isaPrime all exist in memory at
		// once and that's the peak
		long[] aa = new long[sPrimeSz * 3 + (1024 * 1024 /*out of caution*/)];
		return sPrimeSz * 4; // sPrime array
	}
	
	public int v()                    { return _v; }
	public int log2v()                { return _log2v; }
	public long vmask()                { return _vmask; }
	public int modv(long i)     { return (int)(i & ~_vmask); }
	public long divv(long i)   { return i >> _log2v; }
	public int d()                    { return _d; }
	public boolean verbose()                  { return _verbose; }
	public boolean sanityCheck()              { return _sanity; }
	public  String text()              { return _text; }
	public  EList<Integer> ds()     { return _ds; }
	public  EList<Integer> dmap()   { return _dmap; }
	//public ostream log()                  { return _logger; }
	
	public void print(OutputStream out) {
		for(int i = 0; i < _text.length(); i++) {
			if(isCovered(i)) {
				out.write_longlong(rank(i));
			} else {
				out.write_char('-');
			}
			if(i < _text.length()-1) {
				out.write_char(',');
			}
		}
		out.write_string("\n");
	}
	
	private boolean built() {
		return _isaPrime.size() > 0;
	}
	
	private void verbose(String s) {
		if(this.verbose()) {
			//this.log().(s);
			System.err.println(s);
			//this.log().flush();
		}
	}
}
